* Что такое Porto?
** Система управления виртуализационными возможностями ядра
*** cgroups
*** namespaces
*** networking
*** schedulers (CPU, IO)
*** disk images, quotas, etc
*** ...
** API управлением процессами/контейнерами
*** create/destroy
*** start/stop
*** pause/resume
*** set/get properties
*** get data (statistics)
* Почему мы не используем альтернативные решения?
** LXC
   Создан для управления "руками".
   Не удобен для автоматизации.
   Не слишком надежен.
   Docker: LXC -> libcontainer.
** lmctfy
   Нет стабильной версии.
   Не понятен план развития.
   Огромная база кода (150 kSLOC).
   Не устраивает функционально (все равно надо доделывать).
** Docker
   Не про то (но есть libcontainer про то).
   Фокус на deploy и виртуализацию вместо изоляции.
   Их подход - overkill для большинства наших задач. Небесплатный overkill!
   Сырой и очень активно развивается.
** libcgroup
   Плохой дизайн (конкуррентные переносы процессов, обходы /proc).
   Плохая имплементация.
   Не развивается (почти).
   Ограниченная функциональность.
* С какими проблемами мы сейчас сталкиваемся?
** Управление сигруппами "размазано" между несколькими сущностями
*** Cgutils (cgconfig, cgrules)
*** Bsconfig
*** Skynet
*** ISS
*** ...

Надежно?
** libcgroup ненадежен и неудобен
*** гонки
*** нельзя динамически обновить конфигурацию
** Для эксплуатации сложно управлять взаимозависимыми ручками ядра
*** SMART
** Проблемы с динамическими изменениями конфигурации
*** skynet + cgroup.conf = ???
* Как мы собираемся их решить?
** Управление сигруппами "размазано" между несколькими сервисами
   Porto - единственный локальный сервис "настройки" ядра
** libcgroup ненадежен и неудобен
   заменяем на Porto, не повторяем ошибок
** Для эксплуатации сложно управлять взаимозависимыми ручками ядра
   концентрируем знания об ядре в Porto
** Проблемы с динамическими изменениями конфигурации
   изначально закладываем поддержку горячего обновления
* Дизайн Porto

  portod <- portoctl (CLI)
         <- ISS (API)
         <- ...

  unix socket ( /var/run/portod.socket )
  protobuf-based API

  C++ API, Java API, ...
	 
* Планы

**  Фаза 1: начальная версия для первой версии Нирваны (готово)
*** Управление контейнерами через protobuf API
*** Управление контейнерами через CLI
*** Восстановление состояния после незапланированного завершения работы
*** Статистика по фактически использованным ресурсам
*** Логирование (включая сохранение stdout/stderr с ротированием логов)
*** Ограничения по памяти и разделение CPU§
*** Динамическая очистка мусора (удаление неудаленных контейнеров)

** Фаза 2: стабилизация первой версии + функциональность, необходимая для внедрения в search runtime (15 октября)
*** QoS для runtime-контейнеров по памяти и CPU (включая динамические ограничения)
*** Управление сетевыми приоритетом и полосой пропускания контейнеров (без виртуализации)

** Фаза 3: "виртуализация". Основная цель - запуск ОС в контейнере. (1 декабря)
*** Виртуализация сети (виртуальные интерфейсы, настройка роутинга, и т.д.)
*** Виртуализация ФС (включая /dev, /proc и т.д.)
*** "ОС в контейнере"
	
** Фаза 4: все остальное (полностью нескоро)
*** Дисковые квоты
*** Управление дисковыми латентностью и пропускной способностью (QoS)
*** Оверкоммитинг

* Ссылки
  https://wiki.yandex-team.ru/porto


  Спасибо!
