syntax = "proto2";

/*
   Portod daemon listens on /run/portod.socket unix socket.

   Request:    Varint32 length, TPortoRequest  request
   Response:   Varint32 length, TPortoResponse response

   Command is defined by optional nested message field.
   Result will be in nested message with the same name.

   Push notification is send as out of order response.

   Access level depends on client container and uid.

   See defails in porto.md or manpage porto
*/

package Porto;

enum EError {
    // No errors occured.
    Success = 0;

    // Unclassified error, usually unexpected syscall fail.
    Unknown = 1;

    // Unknown method or bad request.
    InvalidMethod = 2;

    // Container with specified name already exists.
    ContainerAlreadyExists = 3;

    // Container with specified name doesn't exist.
    ContainerDoesNotExist = 4;

    // Unknown property specified.
    InvalidProperty = 5;

    // Unknown data specified.
    InvalidData = 6;

    // Invalid value of property or data.
    InvalidValue = 7;

    // Can't perform specified operation in current container state.
    InvalidState = 8;

    // Permanent faulure: old kernel version, missing feature, configuration, etc.
    NotSupported = 9;

    // Temporary failure: too much objects, not enough memory, etc.
    ResourceNotAvailable = 10;

    // Insufficient rights for performing requested operation.
    Permission = 11;

    // Can't create new volume with specified name, because there is already one.
    VolumeAlreadyExists = 12;

    // Volume with specified name doesn't exist.
    VolumeNotFound = 13;

    // Not enough disk space.
    NoSpace = 14;

    // Object in use.
    Busy = 15;

    // Volume already linked with container.
    VolumeAlreadyLinked = 16;

    // Volume not linked with container.
    VolumeNotLinked = 17;

    // Layer with this name already exists.
    LayerAlreadyExists = 18;

    // Layer with this name not found.
    LayerNotFound = 19;

    // Property has no value, data source permanently not available.
    NoValue = 20;

    // Volume under construction or destruction.
    VolumeNotReady = 21;

    // Cannot parse or execute command.
    InvalidCommand = 22;

    // Error code is lost or came from future.
    LostError = 23;

    // Device node not found.
    DeviceNotFound = 24;

    // Path does not match restricitons or does not exist.
    InvalidPath = 25;

    // Wrong or unuseable ip address.
    InvalidNetworkAddress = 26;

    // Porto in system maintenance state.
    PortoFrozen = 27;

    // Label with this name is not set.
    LabelNotFound = 28;

    // Label name does not meet restrictions.
    InvalidLabel = 29;

    // Generic object not found.
    NotFound = 404;

    // Reserved error code for client library.
    SocketError = 502;

    // Reserved error code for client library.
    SocketUnavailable = 503;

    // Reserved error code for client library.
    SocketTimeout = 504;

    // Reserved error code for taints.
    Taint = 666;

    // Internal error code, not for users.
    Queued = 1000;
}


message TPortoRequest {

    /* System methods */

    // Get portod version
    optional TVersionRequest Version = 14;

    // Get portod statistics
    optional TGetSystemRequest GetSystem = 300;

    // Change portod state (for host root user only)
    optional TSetSystemRequest SetSystem = 301;

    /* Container methods */

    // Create new container
    optional TCreateRequest Create = 1;

    // Create new contaienr and auto destroy when client disconnects
    optional TCreateRequest CreateWeak = 17;

    // Force kill all and destroy container and nested containers
    optional TDestroyRequest Destroy = 2;

    // List container names in current namespace
    optional TListRequest List = 3;

    // Start contianer and parents if needed
    optional TStartRequest Start = 7;

    // Kill all and stop container
    optional TStopRequest Stop = 8;

    // Freeze execution
    optional TPauseRequest Pause = 9;

    // Resume execution
    optional TResumeRequest Resume = 10;

    // Send signal to main process
    optional TKillRequest Kill = 13;

    // Restart dead container
    optional TRespawnRequest Respawn = 18;

    // Wait for process finish or change of labels
    optional TWaitRequest Wait = 16;

    // Subscribe to push notifictaions
    optional TWaitRequest AsyncWait = 19;

    /* Container properties */

    // List supported container properties
    optional TListPropertiesRequest ListProperties = 11;

    // Get one property
    optional TGetPropertyRequest GetProperty = 4;

    // Set one property
    optional TSetPropertyRequest SetProperty = 5;

    // Deprecated, now data properties are also read-only properties
    optional TListDataPropertiesRequest ListDataProperties = 12;
    optional TGetDataPropertyRequest GetDataProperty = 6;

    // Get multiple properties for multiple containers
    optional TGetRequest Get = 15;

    /* Container API based on TContainer */

    // Create, configure and start container with volumes
    optional TNewContainerRequest NewContainer = 23;

    // Set multiple container properties
    optional TSetContainerRequest SetContainer = 24;

    // Get multiple properties for multiple containers
    optional TGetContainerRequest GetContainer = 25;

    // Modify symlink in container
    optional TSetSymlinkRequest SetSymlink = 125;

    /* Container labels - user defined key-value */

    // Find containers with labels
    optional TFindLabelRequest FindLabel = 20;

    // Atomic compare and set for label
    optional TSetLabelRequest SetLabel = 21;

    // Atomic add and return for counter in label
    optional TIncLabelRequest IncLabel = 22;

    /* Volume methods */

    optional TListVolumePropertiesRequest ListVolumeProperties = 103;

    // List layers and their properties
    optional TListVolumesRequest ListVolumes = 107;

    // Create, configure and build volume
    optional TCreateVolumeRequest CreateVolume = 104;

    // Change volume properties - for now only resize
    optional TTuneVolumeRequest TuneVolume = 108;

    // Volume API based on TVolume
    optional TNewVolumeRequest NewVolume = 126;
    optional TGetVolumeRequest GetVolume = 127;

    optional TSetVolumeLabelRequest SetVolumeLabel = 128;

    // Add link between container and volume
    optional TLinkVolumeRequest LinkVolume = 105;

    // Same as LinkVolume but fails if target is not supported
    optional TLinkVolumeRequest LinkVolumeTarget = 120;

    // Del link between container and volume
    optional TUnlinkVolumeRequest UnlinkVolume = 106;

    // Same as UnlinkVolume but fails if target is not supported
    optional TUnlinkVolumeRequest UnlinkVolumeTarget = 121;

    /* Layer methods */

    // Import layer from tarball
    optional TImportLayerRequest ImportLayer = 110;

    // Remove layer
    optional TRemoveLayerRequest RemoveLayer = 111;

    // List layers
    optional TListLayersRequest ListLayers = 112;

    // Export volume or layer into tarball
    optional TExportLayerRequest ExportLayer = 113;

    // Get/set layer private (user defined string)
    optional TGetLayerPrivateRequest GetLayerPrivate = 114;
    optional TSetLayerPrivateRequest SetLayerPrivate = 115;

    /* Storage methods */

    // Volume creation creates required storage if missing

    // List storages and meta storages
    optional TListStoragesRequest ListStorages = 116;

    optional TRemoveStorageRequest RemoveStorage = 117;

    // Import storage from tarball
    optional TImportStorageRequest ImportStorage = 118;

    // Export storage into tarball
    optional TExportStorageRequest ExportStorage = 119;

    // Meta storage (bundle for storages and layers)

    optional TMetaStorage CreateMetaStorage = 122;
    optional TMetaStorage ResizeMetaStorage = 123;
    optional TMetaStorage RemoveMetaStorage = 124;

    // Convert path between containers
    optional TConvertPathRequest ConvertPath = 200;

    /* Process methods */

    // Attach process to nested container
    optional TAttachProcessRequest AttachProcess = 201;

    // Find container for process
    optional TLocateProcessRequest LocateProcess = 202;

    // Attach one thread to nexted container
    optional TAttachProcessRequest AttachThread = 203;
}


message TPortoResponse {
    // Actually always set, hack for adding new error codes
    optional EError error = 1 [ default = LostError ];

    // Human readable comment - must be shown to user as is
    optional string errorMsg = 2;

    optional uint64 timestamp = 1000;       // for next changed_since

    /* System methods */

    optional TVersionResponse Version = 8;

    optional TGetSystemResponse GetSystem = 300;
    optional TSetSystemResponse SetSystem = 301;

    /* Container methods */

    optional TListResponse List = 3;

    optional TWaitResponse Wait = 11;

    optional TWaitResponse AsyncWait = 19;

    /* Container properties */

    optional TListPropertiesResponse ListProperties = 6;

    optional TGetPropertyResponse GetProperty = 4;

    // Deprecated
    optional TListDataPropertiesResponse ListDataProperties = 7;
    optional TGetDataPropertyResponse GetDataProperty = 5;

    optional TGetResponse Get = 10;

    /* Container API based on TContainer */

    optional TNewContainerResponse NewContainer = 23;
    optional TSetContainerResponse SetContainer = 24;
    optional TGetContainerResponse GetContainer = 25;

    /* Container Labels */

    optional TFindLabelResponse FindLabel = 20;
    optional TSetLabelResponse SetLabel = 21;
    optional TIncLabelResponse IncLabel = 22;

    /* Volume methods */

    optional TListVolumePropertiesResponse ListVolumeProperties = 12;

    optional TListVolumesResponse ListVolumes = 9;

    optional TVolumeDescription CreateVolume = 13;

    optional TNewVolumeResponse NewVolume = 126;

    optional TGetVolumeResponse GetVolume = 127;

    optional TSetVolumeLabelResponse SetVolumeLabel = 128;

    optional TListLayersResponse ListLayers = 14;

    optional TGetLayerPrivateResponse GetLayerPrivate = 16;

    // List storages and meta storages
    optional TListStoragesResponse ListStorages = 17;

    optional TConvertPathResponse ConvertPath = 15;

    // Process

    optional TLocateProcessResponse LocateProcess = 18;
}


// Common objects


message TStringMap {
    message TStringMapEntry {
        optional string key = 1;
        optional string val = 2;
    }
    // TODO replace with map
    // map<string, string> map = 1;
    repeated TStringMapEntry map = 1;
    optional bool merge = 2;        // in, default: replace
}


message TUintMap {
    message TUintMapEntry {
        optional string key = 1;
        optional uint64 val = 2;
    }
    // TODO replace with map
    // map<string, uint64> map = 1;
    repeated TUintMapEntry map = 1;
    optional bool merge = 2;        // in, default: replace
}


message TError {
    // Actually always set, hack for adding new error codes
    optional EError error = 1 [ default = LostError ];
    optional string msg = 2;
}


message TCred {
    optional string user = 1;       // requires user or uid or both
    optional fixed32 uid = 2;
    optional string group = 3;
    optional fixed32 gid = 4;
    repeated fixed32 grp = 5;       // out, supplementary groups
}


message TCapabilities {
    repeated string cap = 1;        // "SYS_ADMIN", "NET_ADMIN", ...
    optional string hex = 2;        // out
}


// Container


enum EContainerState {
    Undefined = 0;   // internal state
    Stopped = 1;     // "stopped"
    Running = 2;     // "running"
    Dead = 4;        // "dead"
    Meta = 8;        // "meta"
    Starting = 16;   // "starting"
    Stopping = 32;   // "stopping"
    Respawning = 64; // "respawning"
    Paused = 128;    // "paused"
    Destroyed = 256; // internal state

}

message TContainerCommandArgv {
    repeated string argv = 1;
}


message TContainerEnvVar {
    optional string name = 1;
    optional string value = 2;
    optional bool unset = 3;        // out
}

message TContainerEnv {
    repeated TContainerEnvVar var = 1;
    optional bool merge = 2;        // in, default: replace
}


message TContainerUlimit {
    optional string type = 1;
    optional bool unlimited = 2;
    optional uint64 soft = 3;
    optional uint64 hard = 4;
    optional bool inherited = 5;    // out
}

message TContainerUlimits {
    repeated TContainerUlimit ulimit = 1;
    optional bool merge = 2;        // in, default: replace
}


message TContainerControllers {
    repeated string controller = 1; // "memory", "cpu", ...
}


message TContainerCgroup {
    optional string controller = 1;
    optional string path = 2;       // "/sys/fs/cgroup/memory/..."
    optional bool inherited = 3;
}

message TContainerCgroups {
    repeated TContainerCgroup cgroup = 1;
}


message TContainerCpuSet {
    optional string policy = 1;     // inherit|set|node|reserve|threads|cores
    optional uint32 arg = 2;        // for node|reserve|threads|cores
    optional string list = 3;       // for set
    repeated uint32 cpu = 4;        // for set (used if list isn't set)
    optional uint32 count = 5;      // out
}


message TContainerBindMount {
    optional string source = 1;     // path in client container namespace
    optional string target = 2;     // path in container namespace
    repeated string flag = 3;       // "ro", "rec", ...
}

message TContainerBindMounts {
    repeated TContainerBindMount bind = 1;
}


message TContainerVolumeLink {
    optional string volume = 1;     // path client container namespace
    optional string target = 2;     // absolute path in container chroot
    optional bool required = 3;     // cantainer cannot work without it
    optional bool read_only = 4;
}

message TContainerVolumeLinks {
    repeated TContainerVolumeLink link = 1;
}


message TContainerVolumes {
    repeated string volume = 1;     // path client container namespace
}


message TContainerPlace {
    optional string place = 1;      // path in host namespace or "***"
    optional string alias = 2;      // single word name
}

message TContainerPlaceConfig {
    repeated TContainerPlace cfg = 1;
}


message TContainerDevice {
    optional string device = 1;     // "/dev/foo"
    optional string access = 2;     // "[r][w][m][-][?]"
}

message TContainerDevices {
    repeated TContainerDevice device = 1;
    optional bool merge = 2;        // in, default: replace
}


message TContainerNetOption {
    optional string opt = 1;
    repeated string arg = 2;
}

message TContainerNetConfig {
    repeated TContainerNetOption cfg = 1;
    optional bool inherited = 2;    // out, same net namespace as parent
}


message TContainerIpLimit {
    optional string policy = 1;     // any|none|some
    repeated string ip = 2;         // <ipv4|ipv6>[/<mask>]
}


message TContainerIpConfig {
    message TContainerIp {
        optional string dev = 1;
        optional string ip = 2;     // ipv4|ipv6
    }
    repeated TContainerIp cfg = 1;
}


message TVmStat {
    optional uint64 count = 1;      // process count
    optional uint64 size = 2;
    optional uint64 max_size = 3;
    optional uint64 used = 4;
    optional uint64 max_used = 5;
    optional uint64 anon = 6;
    optional uint64 file = 7;
    optional uint64 shmem = 8;
    optional uint64 huge = 9;
    optional uint64 swap = 10;
    optional uint64 data = 11;
    optional uint64 stack = 12;
    optional uint64 code = 13;
    optional uint64 locked = 14;
    optional uint64 table = 15;
}


message TContainer {
    optional string name = 1;           // in client namespace
    optional string absolute_name = 2;  // out, "/porto/..."
    optional string state = 3;          // out
    optional EContainerState st = 200;  // out
    optional uint64 id = 4;             // out
    optional uint32 level = 5;          // out
    optional string parent = 6;         // out, "/porto/..."
    optional bool weak = 7;             // destroy if client disconnects
    optional string private = 8;
    optional TStringMap labels = 9;

    optional string command = 10;
    optional TContainerCommandArgv command_argv = 11;   // verbatim command line
    optional TContainerEnv env = 12;
    optional TContainerUlimits ulimit = 13;
    optional string core_command = 14;

    optional bool isolate = 15;         // new pid/ipc/utc namespaces, do not inherit env
    optional string virt_mode = 16;     // os|app|job|host
    optional string enable_porto = 17;  // false|read-isolate|read-only|isolate|child-only|true
    optional string porto_namespace = 18;
    optional string absolute_namespace = 19;    // out

    optional int32 root_pid = 20;       // out
    optional int32 exit_status = 21;    // out, same as in syscall wait
    optional int32 exit_code = 22;      // out, >= 0 - exit_code, < 0 - signal, -99 - oom
    optional bool core_dumped = 23;     // out
    optional TError start_error = 24;   // out
    optional uint64 time = 25;          // out, sec, runnning time
    optional uint64 dead_time = 26;     // out, sec, time since death
    optional uint64 aging_time = 27;    // sec, auto remove stale dead containers

    optional TCred task_cred = 30;
    optional string user = 31;
    optional string group = 32;

    optional TCred owner_cred = 33;
    optional string owner_user = 34;
    optional string owner_group = 35;

    optional TCapabilities capabilities = 36;   // limit for capabilities
    optional TCapabilities capabilities_ambient = 37;
    optional TCapabilities capabilities_allowed = 38;           // out
    optional TCapabilities capabilities_ambient_allowed = 39;   // out

    optional string root = 40;          // in parent namespace
    optional string root_path = 41;     // out, in client namespace
    optional bool root_readonly = 42;
    optional TContainerBindMounts bind = 43;
    optional TStringMap symlink = 44;
    optional TContainerDevices devices = 45;
    optional TContainerPlaceConfig place = 46;
    optional TUintMap place_limit = 47;
    optional TUintMap place_usage = 48;

    optional string cwd = 50;
    optional string stdin_path = 51;
    optional string stdout_path = 52;
    optional string stderr_path = 53;
    optional uint64 stdout_limit = 54;
    optional uint64 stdout_offset = 55; // out
    optional uint64 stderr_offset = 56; // out
    optional uint32 umask = 57;         // default 0775

    optional bool respawn = 60;         // auto-restart after death
    optional uint64 respawn_count = 61;
    optional uint64 max_respawns = 62;
    optional uint64 respawn_delay = 63; // nsec, default 1s

    optional uint64 creation_time = 70; // out, sec since epoch
    optional uint64 start_time = 71;    // out, sec since epoch
    optional uint64 death_time = 72;    // out, sec since epoch
    optional uint64 change_time = 73;   // out, sec since epoch
    optional bool no_changes = 74;      // out, change_time < changed_since

    optional TContainerControllers controllers = 80;
    optional TContainerCgroups cgroups = 81;     // out

    optional string cpu_policy = 100;   // normal|idle|batch|high|rt
    optional double cpu_weight = 101;   // 0.01 .. 100

    optional double cpu_guarantee = 102;        // cores
    optional double cpu_guarantee_total = 103;  // cores
    optional double cpu_limit = 104;            // cores
    optional double cpu_limit_total = 105;      // cores
    optional uint64 cpu_period = 106;           // nsec

    optional TContainerCpuSet cpu_set = 107;
    optional TContainerCpuSet cpu_set_affinity = 108;     // out

    optional uint64 cpu_usage = 109;            // out, nsec
    optional uint64 cpu_usage_system = 110;     // out, nsec
    optional uint64 cpu_wait = 111;             // out, nsec
    optional uint64 cpu_throttled = 112;        // out, nsec

    optional uint64 process_count = 120;        // out
    optional uint64 thread_count = 121;         // out
    optional uint64 thread_limit = 122;

    optional string io_policy = 201;    // none|rt|high|normal|batch|idle
    optional double io_weight = 202;    // 0.01 .. 100

    optional TUintMap io_limit = 204;       // bytes/sec
    optional TUintMap io_ops_limit = 205;   // operations/sec

    optional TUintMap io_read = 206;        // out, bytes
    optional TUintMap io_write = 207;       // out, bytes
    optional TUintMap io_ops = 208;         // out, operations
    optional TUintMap io_time = 209;        // out, nsec
    optional TUintMap io_wait = 210;        // out, nsec

    optional uint64 memory_usage = 340;         // out, bytes

    optional uint64 memory_guarantee = 341;     // bytes
    optional uint64 memory_guarantee_total = 342;   // out

    optional uint64 memory_limit = 343;         // bytes
    optional uint64 memory_limit_total = 344;   // out

    optional uint64 anon_usage = 345;           // out, bytes
    optional uint64 anon_max_usage = 346;       // bytes
    optional uint64 anon_limit = 347;           // bytes
    optional uint64 anon_limit_total = 348;     // bytes

    optional uint64 cache_usage = 349;          // out, bytes
    optional uint64 dirty_limit = 350;          // bytes

    optional uint64 hugetlb_usage = 351;        // out, bytes
    optional uint64 hugetlb_limit = 352;        // bytes

    optional bool recharge_on_pgfault = 353;
    optional bool pressurize_on_death = 354;
    optional bool anon_only = 355;

    optional uint64 minor_faults = 356;         // out
    optional uint64 major_faults = 357;         // out
    optional uint64 memory_reclaimed = 358;     // out, bytes
    optional TVmStat virtual_memory = 359;      // out

    optional uint64 oom_kills = 390;            // out
    optional uint64 oom_kills_total = 391;      // out
    optional int32 oom_score_adj = 392;         // -1000 .. +1000
    optional bool oom_killed = 393;             // out
    optional bool oom_is_fatal = 394;           // kill container at oom

    optional TContainerNetConfig net = 400;
    optional TContainerIpLimit ip_limit = 401;
    optional TContainerIpConfig ip = 402;
    optional TContainerIpConfig default_gw = 403;
    optional string hostname = 404;             // default: inherit
    optional string resolv_conf = 405;
    optional string etc_hosts = 406;
    optional TStringMap sysctl = 407;
    optional TUintMap net_guarantee = 408;      // bytes/sec
    optional TUintMap net_limit = 409;          // bytes/sec
    optional TUintMap net_rx_limit = 410;       // bytes/sec
    optional TUintMap net_class_id = 411;       // out
    optional string net_tos = 412;              // "CS0" .. "CS7"

    optional TUintMap net_bytes = 421;          // out
    optional TUintMap net_packets = 422;        // out
    optional TUintMap net_drops = 423;          // out
    optional TUintMap net_overlimits = 424;     // out
    optional TUintMap net_rx_bytes = 425;       // out
    optional TUintMap net_rx_packets = 426;     // out
    optional TUintMap net_rx_drops = 427;       // out
    optional TUintMap net_tx_bytes = 428;       // out
    optional TUintMap net_tx_packets = 429;     // out
    optional TUintMap net_tx_drops = 430;       // out

    optional TContainerVolumeLinks volumes_linked = 500; // out
    optional TContainerVolumes volumes_required = 501;
    optional TContainerVolumes volumes_owned = 502;

    repeated TError error = 1000;   // out, fatal problems
    repeated TError warning = 1001; // out, non-fatal problems
    repeated TError taint = 1002;   // out, misconfigurations
}


// Volumes

message TVolumeProperty {
    optional string name = 1;
    optional string value = 2;
}

message TVolumeDescription {
    optional string path = 1;           // path in client namespace
    repeated TVolumeProperty properties = 2;
    // TODO replace with map
    // map<string, string> properties = 2;
    repeated string containers = 3;     // linked containers (legacy)
    repeated TVolumeLink links = 4;     // linked containers with details

    optional uint64 change_time = 5;    // sec since epoch
    optional bool no_changes = 6;       // change_time < changed_since
}


message TVolumeLink {
    optional string container = 1;
    optional string target = 2;         // absolute path in container, default: anon
    optional bool required = 3;         // container cannot work without it
    optional bool read_only = 4;
    optional string host_target = 5;    // out, absolute path in host
}

message TVolumeResource {
    optional uint64 limit = 1;          // bytes or inodes
    optional uint64 guarantee = 2;      // bytes or inodes
    optional uint64 usage = 3;          // out, bytes or inodes
    optional uint64 available = 4;      // out, bytes or inodes
}

message TVolumeDirectory {
    optional string path = 1;           // relative path in volume
    optional TCred cred = 2;            // default: volume cred
    optional fixed32 permissions = 3;   // default: volume permissions
}

message TVolumeSymlink {
    optional string path = 1;           // relative path in volume
    optional string target_path = 2;
}

message TVolumeShare {
    optional string path = 1;           // relative path in volume
    optional string origin_path = 2;    // absolute path to origin
    optional bool cow = 3;              // default: mutable share
}

message TVolume {
    optional string path = 1;               // path in container, default: auto
    optional string container = 2;          // defaultL self (client container)
    repeated TVolumeLink links = 3;         // default: anon link to self

    optional string id = 4;                 // out
    optional string state = 5;              // out

    optional string private_value = 6;      // at most 4096 bytes

    optional string device_name = 7;        // out

    optional string backend = 10;           // default: auto
    optional string place = 11;             // path in host or alias, default from client container
    optional string storage = 12;           // persistent storage, path or name, default: non-persistent
    repeated string layers = 13;            // name or path
    optional bool read_only = 14;
    optional TStringMap labels = 15;

    // defines root directory user, group and permissions
    optional TCred cred = 20;               // default: self task cred
    optional fixed32 permissions = 21;      // default: 0775

    optional TVolumeResource space = 22;
    optional TVolumeResource inodes = 23;

    optional TCred owner = 30;              // default: self owner
    optional string owner_container = 31;   // default: self
    optional string place_key = 32;         // out, key for place_limit
    optional string creator = 33;           // out
    optional bool auto_path = 34;           // out
    optional uint32 device_index = 35;      // out
    optional uint64 build_time = 37;        // out, sec since epoch

    // customization at creation
    repeated TVolumeDirectory directories = 40; // in
    repeated TVolumeSymlink symlinks = 41;      // in
    repeated TVolumeShare shares = 42;          // in

    optional uint64 change_time = 50;       // out, sec since epoch
    optional bool no_changes = 51;          // out, change_time < changed_since
}


message TLayer {
    optional string name = 1;           // name or meta/name
    optional string owner_user = 2;
    optional string owner_group = 3;
    optional uint64 last_usage = 4;     // out, sec since last usage
    optional string private_value = 5;
}


message TStorage {
    optional string name = 1;           // name or meta/name
    optional string owner_user = 2;
    optional string owner_group = 3;
    optional uint64 last_usage = 4;     // out, sec since last usage
    optional string private_value = 5;
}


message TMetaStorage {
    optional string name = 1;
    optional string place = 2;
    optional string private_value = 3;
    optional uint64 space_limit = 4;        // bytes
    optional uint64 inode_limit = 5;        // inodes

    optional uint64 space_used = 6;         // out, bytes
    optional uint64 space_available = 7;    // out, bytes
    optional uint64 inode_used = 8;         // out, inodes
    optional uint64 inode_available = 9;    // out, inodes
    optional string owner_user = 10;        // out
    optional string owner_group = 11;       // out
    optional uint64 last_usage = 12;        // out, sec since last usage
}


// COMMANDS

// System

// Get porto version
message TVersionRequest {
}

message TVersionResponse {
    optional string tag = 1;
    optional string revision = 2;
}


// Get porto statistics
message TGetSystemRequest {
}

message TGetSystemResponse {
    optional string porto_version = 1;
    optional string porto_revision = 2;
    optional string kernel_version = 3;

    optional fixed64 errors = 4;
    optional fixed64 warnings = 5;
    optional fixed64 porto_starts = 6;
    optional fixed64 porto_uptime = 7;
    optional fixed64 master_uptime = 8;
    optional fixed64 taints = 9;

    optional bool frozen = 10;
    optional bool verbose = 100;
    optional bool debug = 101;
    optional fixed64 log_lines = 102;
    optional fixed64 log_bytes = 103;

    optional fixed64 stream_rotate_bytes = 104;
    optional fixed64 stream_rotate_errors = 105;

    optional fixed64 log_lines_lost = 106;
    optional fixed64 log_bytes_lost = 107;
    optional fixed64 log_open = 108;

    optional fixed64 container_count = 200;
    optional fixed64 container_limit = 201;
    optional fixed64 container_running = 202;
    optional fixed64 container_created = 203;
    optional fixed64 container_started = 204;
    optional fixed64 container_start_failed = 205;
    optional fixed64 container_oom = 206;
    optional fixed64 container_buried = 207;
    optional fixed64 container_lost = 208;
    optional fixed64 container_tainted = 209;

    optional fixed64 volume_count = 300;
    optional fixed64 volume_limit = 301;
    optional fixed64 volume_created = 303;
    optional fixed64 volume_failed = 304;
    optional fixed64 volume_links = 305;
    optional fixed64 volume_links_mounted = 306;
    optional fixed64 volume_lost = 307;

    optional fixed64 layer_import = 390;
    optional fixed64 layer_export = 391;
    optional fixed64 layer_remove = 392;

    optional fixed64 client_count = 400;
    optional fixed64 client_max = 401;
    optional fixed64 client_connected = 402;

    optional fixed64 request_queued = 500;
    optional fixed64 request_completed = 501;
    optional fixed64 request_failed = 502;
    optional fixed64 request_threads = 503;
    optional fixed64 request_longer_1s = 504;
    optional fixed64 request_longer_3s = 505;
    optional fixed64 request_longer_30s = 506;
    optional fixed64 request_longer_5m = 507;

    optional fixed64 fail_system = 600;
    optional fixed64 fail_invalid_value = 601;
    optional fixed64 fail_invalid_command = 602;
    optional fixed64 fail_memory_guarantee = 603;

    optional fixed64 network_count = 700;
    optional fixed64 network_created = 701;
    optional fixed64 network_problems = 702;
    optional fixed64 network_repairs = 703;
}


// Change porto state
message TSetSystemRequest {
    optional bool frozen = 10;
    optional bool verbose = 100;
    optional bool debug = 101;
}

message TSetSystemResponse {
}

message TNewContainerRequest {
    optional TContainer container = 1;
    repeated TVolume volume = 2;
    optional bool start = 3;
}

message TNewContainerResponse {
    optional TContainer container = 1;
    repeated TVolume volume = 2;
}

message TSetContainerRequest {
    optional TContainer container = 1;
}

message TSetContainerResponse {
}

message TGetContainerRequest {
    repeated string name = 1;           // names or wildcards, default: all
    repeated string label = 2;          // labels or wildcards
    repeated string property = 3;       // property names, default: all
    optional uint64 changed_since = 4;  // change_time >= changed_since
}

message TGetContainerResponse {
    repeated TContainer container = 1;
    optional string absolute_namespace = 2;
}

// List available properties
message TListPropertiesRequest {
}

message TListPropertiesResponse {
    message TContainerPropertyListEntry {
        optional string name = 1;
        optional string desc = 2;
        optional bool read_only = 3;
        optional bool dynamic = 4;
    }
    repeated TContainerPropertyListEntry list = 1;
}


// deprecated, use ListProperties
message TListDataPropertiesRequest {
}

message TListDataPropertiesResponse {
    message TContainerDataListEntry {
        optional string name = 1;
        optional string desc = 2;
    }
    repeated TContainerDataListEntry list = 1;
}


// Create stopped container
message TCreateRequest {
    optional string name = 1;
}


// Stop and destroy container
message TDestroyRequest {
    optional string name = 1;
}


// List container names
message TListRequest {
    optional string mask = 1;
    optional uint64 changed_since = 2;  // change_time >= changed_since
}

message TListResponse {
    repeated string name = 1;
    optional string absolute_namespace = 2;
}


// Read one property
message TGetPropertyRequest {
    optional string name = 1;
    optional string property = 2;
    // update cached counters
    optional bool sync = 3;
    optional bool real = 4;
}

message TGetPropertyResponse {
    optional string value = 1;
}


// Alias for GetProperty, deprecated
message TGetDataPropertyRequest {
    optional string name = 1;
    optional string data = 2;
    // update cached counters
    optional bool sync = 3;
    optional bool real = 4;
}

message TGetDataPropertyResponse {
    optional string value = 1;
}


// Change one property
message TSetPropertyRequest {
    optional string name = 1;
    optional string property = 2;
    optional string value = 3;
}


// Get multiple properties/data of many containers with one request
message TGetRequest {
    // list of containers or wildcards, "***" - all
    repeated string name = 1;

    // list of properties/data
    repeated string variable = 2;

    // do not wait busy containers
    optional bool nonblock = 3;

    // update cached counters
    optional bool sync = 4;
    optional bool real = 5;

    // change_time >= changed_since
    optional uint64 changed_since = 6;
}

message TGetResponse {
    message TContainerGetValueResponse {
        optional string variable = 1;
        optional EError error = 2;
        optional string errorMsg = 3;
        optional string value = 4;
    }

    message TContainerGetListResponse {
        optional string name = 1;
        repeated TContainerGetValueResponse keyval = 2;

        optional uint64 change_time = 3;
        optional bool no_changes = 4;   // change_time < changed_since
    }

    repeated TContainerGetListResponse list = 1;
}


// Start stopped container
message TStartRequest {
    optional string name = 1;
}


// Restart dead container
message TRespawnRequest {
    optional string name = 1;
}


// Stop dead or running container
message TStopRequest {
    optional string name = 1;
    // Timeout in 1/1000 seconds between SIGTERM and SIGKILL, default 30s
    optional uint32 timeout_ms = 2;
}


// Freeze running container
message TPauseRequest {
    optional string name = 1;
}


// Unfreeze paused container
message TResumeRequest {
    optional string name = 1;
}


// Translate filesystem path between containers
message TConvertPathRequest {
    optional string path = 1;
    optional string source = 2;
    optional string destination = 3;
}

message TConvertPathResponse {
    optional string path = 1;
}


// Wait while container(s) is/are in running state
message TWaitRequest {
    // list of containers or wildcards, "***" - all
    repeated string name = 1;

    // timeout in 1/1000 seconds, 0 - nonblock
    optional uint32 timeout_ms = 2;

    // list of label names or wildcards
    repeated string label = 3;
}

message TWaitResponse {
    optional string name = 1;           // container name
    optional string state = 2;          // container state or "timeout"
    optional uint64 when = 3;           // unix time stamp in seconds
    optional string label = 4;
    optional string value = 5;
    optional EContainerState st = 6;
}


// Send signal main process in container
message TKillRequest {
    optional string name = 1;
    optional int32 sig = 2;
}


// Move process into container
message TAttachProcessRequest {
    optional string name = 1;
    optional uint32 pid = 2;
    optional string comm = 3; // ignored if empty
}


// Determine container by pid
message TLocateProcessRequest {
    optional uint32 pid = 1;
    optional string comm = 2; // ignored if empty
}

message TLocateProcessResponse {
    optional string name = 1;
}


// Labels


message TFindLabelRequest {
    optional string mask = 1;           // containers name or wildcard
    optional string state = 2;          // filter by container state
    optional string label = 3;          // label name or wildcard
    optional string value = 4;          // filter by label value
}

message TFindLabelResponse {
    message TFindLabelEntry {
        optional string name = 1;
        optional string state = 2;
        optional string label = 3;
        optional string value = 4;
    }
    repeated TFindLabelEntry list = 1;
}


message TSetLabelRequest {
    optional string name = 1;
    optional string label = 2;
    optional string value = 3;
    optional string prev_value = 4;     // fail with Busy if does not match
    optional string state = 5;          // fail with InvalidState if not match
}

message TSetLabelResponse {
    optional string prev_value = 1;
    optional string state = 2;
}


message TIncLabelRequest {
    optional string name = 1;
    optional string label = 2;          // missing label starts from 0
    optional int64 add = 3 [ default = 1];
}

message TIncLabelResponse {
    optional int64 result = 1;
}


message TSetSymlinkRequest {
    optional string container = 1;
    optional string symlink = 2;
    optional string target = 3;
}


// Volumes


message TNewVolumeRequest {
    optional TVolume volume = 1;
}

message TNewVolumeResponse {
    optional TVolume volume = 1;
}


message TGetVolumeRequest {
    optional string container = 1;  // get paths in container, default: self (client container)
    repeated string path = 2;       // volume path in container, default: all
    optional uint64 changed_since = 3;  // change_time >= changed_since
    repeated string label = 4;      // labels or wildcards
}

message TGetVolumeResponse {
    repeated TVolume volume = 1;
}


// List available volume properties
message TListVolumePropertiesRequest {
}

message TListVolumePropertiesResponse {
    message TVolumePropertyDescription {
        optional string name = 1;
        optional string desc = 2;
    }
    repeated TVolumePropertyDescription list = 1;
}


// Create new volume
// "createVolume" returns TVolumeDescription in "volume"
message TCreateVolumeRequest {
    optional string path = 1;
    repeated TVolumeProperty properties = 2;
    // TODO replace with map
    // map<string, string> properties = 2;
}


message TLinkVolumeRequest {
    optional string path = 1;
    optional string container = 2;      // default - self (client container)
    optional string target = 3;         // path in container, "" - anon
    optional bool required = 4;         // stop container at fail
    optional bool read_only = 5;
}


message TUnlinkVolumeRequest {
    optional string path = 1;
    optional string container = 2;      // default - self, "***" - all
    optional bool strict = 3;           // non-lazy umount
    optional string target = 4;         // path in container, "" - anon, default - "***" - all
}


message TListVolumesRequest {
    optional string path = 1;
    optional string container = 2;
    optional uint64 changed_since = 3;  // change_time >= changed_since
}

message TListVolumesResponse {
    repeated TVolumeDescription volumes = 1;
}


message TTuneVolumeRequest {
    optional string path = 1;
    repeated TVolumeProperty properties = 2;
    // TODO replace with map
    // map<string, string> properties = 2;
}


message TSetVolumeLabelRequest {
    optional string path = 1;
    optional string label = 2;
    optional string value = 3;
    optional string prev_value = 4;     // fail with Busy if does not match
}

message TSetVolumeLabelResponse {
    optional string prev_value = 1;
}

// Layers


message TListLayersRequest {
    optional string place = 1;  // default from client container
    optional string mask = 2;
}

message TListLayersResponse {
    repeated string layer = 1;  // layer names (legacy)
    repeated TLayer layers = 2; // layer with description
}


message TImportLayerRequest {
    optional string layer = 1;
    optional string tarball = 2;
    optional bool merge = 3;
    optional string place = 4;
    optional string private_value = 5;
    optional string compress = 6;
}


message TExportLayerRequest {
    optional string volume = 1;
    optional string tarball = 2;
    optional string layer = 3;
    optional string place = 4;
    optional string compress = 5;
}


message TRemoveLayerRequest {
    optional string layer = 1;
    optional string place = 2;
}


message TGetLayerPrivateRequest {
    optional string layer = 1;
    optional string place = 2;
}

message TGetLayerPrivateResponse {
    optional string private_value = 1;
}


message TSetLayerPrivateRequest {
    optional string layer = 1;
    optional string place = 2;
    optional string private_value = 3;
}


// Storages


message TListStoragesRequest {
    optional string place = 1;
    optional string mask = 2;
}

message TListStoragesResponse {
    repeated TStorage storages = 1;
    repeated TMetaStorage meta_storages = 2;
}


message TRemoveStorageRequest {
    optional string name = 1;
    optional string place = 2;
}


message TImportStorageRequest {
    optional string name = 1;
    optional string tarball = 2;
    optional string place = 3;
    optional string private_value = 5;
    optional string compress = 6;
}


message TExportStorageRequest {
    optional string name = 1;
    optional string tarball = 2;
    optional string place = 3;
    optional string compress = 4;
}
