#!/usr/bin/env ruby

require 'json'
require 'fileutils'
require 'optparse'

options = {
  reserve: 128 * 1024 * 1024
}

OptionParser.new do |opts|
  opts.banner = <<END
Usage: docker2porto [options] <image>

Options:
END

  opts.on("-r", "--reserve [BYTES]",
          Integer,
          "Reserve given amount of free space on the image") do |v|
    options[:reserve] = v
  end
end.parse!

capabilities = [ "CHOWN", "DAC_OVERRIDE", "FSETID", "FOWNER", "MKNOD", "NET_RAW", "SETGID", "SETUID", "SETFCAP", "SETPCAP", "NET_BIND_SERVICE", "SYS_CHROOT", "KILL", "AUDIT_WRITE" ].join ";"

def docker_snapshot(image, data, metadata)
  name = "docker2porto"
  system "docker pull #{image}" or abort "Docker can't pull image #{image}"
  system "docker stop #{name}"
  system "docker rm #{name}"
  system "docker run --name #{name} -d #{image}" or abort "Docker can't start container #{name}"
  #need new docker:
  #system "docker create --name #{name} #{image}" or abort "Docker can't create container #{name}"
  system "docker stop #{name}" or abort "Docker can't stop container #{name}"
  system "docker inspect #{name} > #{metadata}" or abort "Docker can't export #{name} metadata"
  system "docker export #{name} > #{data}" or abort "Docker can't export #{name} data"
  system "docker rm #{name}"
end

def cleanup(data, metadata)
  FileUtils.rm([ data, metadata ])
end

def generate_loop(tar, rootfs, reserve)
  size = File.size(tar)
  size += 32 * 1024 * 1024 # filesystem metadata
  size += reserve
  system "umount tmp"
  system "dd if=/dev/zero of=#{rootfs} bs=1 count=0 seek=#{size}" or abort "Can't create image file"
  system "mkfs.ext4 -F #{rootfs}" or abort "Can't create filesystem"
  FileUtils.mkdir_p('tmp') or abort "Can't create temporary directory"
  system "mount -o loop #{rootfs} tmp" or abort "Can't mount loop device"
  system "tar xf #{tar} -C tmp" or abort "Can't untar snapshot"
  system "umount tmp"
  FileUtils.rmdir('tmp')
end

def escape_arg(s)
  s.gsub('"'){'\\"'}
end

def escape_env(s)
  s.gsub(';'){'\\;'}
end

def generate_conf(script, name, rootfs, meta, capabilities)
  config = {}

  id = meta["Id"]

  cmd = []
  cmd += meta["Config"]["Entrypoint"] if meta["Config"]["Entrypoint"]
  cmd += meta["Config"]["Cmd"]

  env = meta["Config"]["Env"]

  config["command"] = cmd.shift
  cmd.each { |s| config["command"] += " \"#{escape_arg(s)}\"" }

  config["env"] = ""
  env.each { |s| config["env"] += "#{escape_env(s)};" }

  config["cwd"] = "/#{meta["Config"]["WorkingDir"]}"
  config["root"] = "$DIR/#{rootfs}"

  config["user"] = "root"
  config["group"] = "root"
  config["capabilities"] = capabilities

  portoctl = "exec $PORTOCTL exec #{name} hostname=\"$HOSTNAME\""
  config.each { |k, v| portoctl += " #{k}=\"#{escape_arg(v)}\""}

  text = <<END
#!/bin/sh -x

DIR="#{Dir.pwd}"
PORTOCTL="portoctl"
HOSTNAME="#{name}"

[ -f "../portoctl" ] && PORTOCTL="../portoctl"

#{portoctl}
END

  File.write(script, text)
end

tmp_data = "data.tar"
tmp_meta = "meta.json"

image = ARGV.shift
abort "Please specify docker image!" if not image

script = "#{image}"

abort "Need root privileges" if Process.uid != 0

puts ">>> Create docker container snapshot..."
docker_snapshot(image, tmp_data, tmp_meta)
json = JSON.parse(File.read(tmp_meta))[0]
puts ">>> Generate root filesystem..."
rootfs = "#{json["Image"]}"
generate_loop(tmp_data, rootfs, options[:reserve])
puts ">>> Generate config..."
generate_conf(script, image, rootfs, json, capabilities)
puts ">>> Cleanup..."
FileUtils.chmod "+x", script
cleanup(tmp_data, tmp_meta)
