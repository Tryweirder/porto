- full dump on sigsegv
- ? autodestroy property
- ? portoctl run -f <MANIFEST> | <MANIFEST STRING>
- ? cpu_cores property to reserve some cores for a container
- ? portoctl top - sort containers by used resources
- ? some kind of io usage data (iops/bytes)

# nekt0n
- add namespaces
- ? get rid of globals/static which have class types (http://google-styleguide.googlecode.com/svn/trunk/cppguide.html#Static_and_Global_Variables)
- ? portoctl inpect to export everything in JSON

# network
- ? net_prio 0-7 -> 0-99

# phase 3
- root property to isolate fs (loop if file chroot if dir)
- ? readonly_root
- ? isolate ipc property
- ? when to enable user namespace
- hostname property + isolate uts
- net:<none?|host|bridge> - create veth pair and setup routing + masquerading + generate random ip/mask or use provided
- net_map: map host port to container when bridge used
- ? mount proc proc proc nodev,noexec,nosuid 0 0; run run tmpfs nodev,noexec,nosuid,relatime,size=1m,mode=0755 0 0; shm dev/shm tmpfs nodev,nosuid,noexec 0 0
  we can prepare everything when fs is isolated
- bind <host path> <container path>;
- ? devices c 1:3 rwm; c 1:5 rwm; c 1:9 rwm; c 1:8 rwm; c 136:* rwm; c 5:2 rwm
- ? tty - create pty slave and use it as console inside of container
- restrict_sys - remount to readonly /proc/sys, /sys and mask over sysrq-trigger + /proc/irq and /proc/bus
- ? remount /sys (as we do with /proc) to hide things like /sys/class/net
- more on net: docker/docs/sources/articles/networking.md

# phase 2
- rt: create cgroup for non-smart tasks and throttle them
- ? use SO_PEERCRED to isolate parent containers from child in portod

# phase X
- ? kernel support for cgroup to limit allowed ports

# cleanup
- remove extern AckExitStatus from container->Stop()
- rotate subprocess stdout/stderr
- move all 'extern "C"' into one file

# debug
- porto debug
- porto debug set container_kill_timeout 100000
- ? porto config
