- ? do periodic persistence checks
- ? move property apply code into property method

# properties
- ? supplementary_groups
- ? umask
- ? autodestroy
- ? cpu_cores - reserve some cores for a container

# portoinit
- ? portoctl run -f <MANIFEST> | <MANIFEST STRING>

# nekt0n
- add namespaces
- ? get rid of globals/static which have class types (http://google-styleguide.googlecode.com/svn/trunk/cppguide.html#Static_and_Global_Variables)
- ? portoctl inspect to export everything in JSON

# phase 4
##
- ? ro+rw images for container distribution
## net
- L3 configuration via properties (ip/mask/broarcast/routes)
- net: bridge to create veth pair, then add side A to the specified bridge and
  side B to the container

# phase 3
## other
- ? when to enable user namespace
## net
- ? net_prio 0-7 -> 0-99

# phase 2
- rt: create cgroup for non-smart tasks and throttle them
- ? use SO_PEERCRED to isolate parent containers from child in portod

# phase X
- ? kernel support for cgroup to limit allowed ports
- ? kernel support for cgroup coredump path
- ? full dump on sigsegv
- ? start portod in container -> need to parse mountinfo, not mounts (because mountinfo skips mounts outside of chroot)

# cleanup
- remove extern AckExitStatus from container->Stop()
- rotate subprocess stdout/stderr
- move all 'extern "C"' into one file
- different log levels (error, normal, verbose)
- use some kind of reference count for accounting running children
- ? remove start_errno data
- add some kind of event queue and use it to rotate logs and respawn containers
